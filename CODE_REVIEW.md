# Code Review — my-bot-grammy

Дата: 2025-10-01
Область ревью: весь каталог `src/`, конфиги (TypeScript, Biome), Prisma schema, package.json, runtime (Bun), сборка, и готовые артефакты в `build/`.

## Краткая оценка
Проект аккуратно организован вокруг grammy, с разнесением команд/колбэков/конверсейшенов/фильтров/шедулеров и вспомогательных хелперов. Используются полезные плагины grammy (+ conversations, hydrate, ratelimiter, prisma storage). Есть Prisma со схемой для пользователей/сессий/Wordle/Steam, и периодические задачи через node-cron. В целом — хорошая модульность и читаемость.

Ниже — список конкретных замечаний и улучшений, сгруппированных по приоритету.

---

## Высокий приоритет (Runtime, Данные, Надёжность)

1) Неконсистентность запуска и сборки
- В package.json: `"start": "bun build/bot.js"` — некорректно (команда bun запускает файлы как `bun run <script>` или `bun <file>`). На практике вы, видимо, запускаете скомпилированный JS напрямую: `bun build/bot.js` — это невалидная форма.
- README указывает `bun run index.js`, которого нет. В `build/` есть `bot.js` — значит корректные варианты:
  - Либо запускать напрямую: `bun build/bot.js` (неправильно), корректно: `bun run build/bot.js` или просто `bun build/bot.js`? Правильно — `bun run` вызывает npm-скрипт. Для файла используйте: `bun ./build/bot.js`.
  - Исправить скрипты: `"start": "bun ./build/bot.js"`, `"build": "bunx tsc"`.
- Проверьте, что импорт путей в runtime указывает на `.js` (в исходниках импортируется с `.js` — это ок с TS `verbatimModuleSyntax` и `bundler` resolution, если компилируете в ES-модули).

2) Prisma Client generate/migrate и схема
- В `package.json` `prisma` скрипт делает `migrate dev` + `generate`. На CI и в проде миграции так делать нельзя (нужен безопасный процесс). Рекомендация:
  - Dev: оставить `prisma:dev` для `migrate dev`.
  - Prod/CI: использовать `prisma migrate deploy` и отдельно `prisma generate`.
- В `schema.prisma` все `Float` для балансов/очков ок, но для денег лучше `Decimal` (или целые в минимальных единицах), чтобы исключить ошибки округления.

3) Сеть и ошибки API
- Steam API/PlayerDB и CoinGecko используются без таймаутов/ретраев/ограничений. Возможны зависания и падения при сетевых сбоях.
  - Вставить таймауты (axios: timeout, AbortController для fetch), экспоненциальный retry (например, p-retry), чёткую обработку non-2xx.
  - Уважать rate limits: уже есть пара задержек, но лучше централизовать, добавить backoff по статусам 429/5xx.
- Все внешние URL лучше вынести в конфиг.

4) Безопасность и секреты
- Использование `process.env.BOT_TOKEN`, `STEAM_API_KEY` ok, но нет явной валидации при старте. Добавить проверку обязательных переменных и фатальный выход с понятной ошибкой.
- В `savePhoto` сохраняете файл в `./src/image/image.png`. Смешение runtime-артефактов и исходников — риск. Лучше сохранять в `./data/` или `./storage/` и игнорировать в VCS.

5) Глобальные идентификаторы чатов
- Хардкод: `const groupID = "-1002352664972"` (в нескольких местах). Лучше конфиг через env или централизованный конфиг модуль.

6) Консистентность сессии и базы
- Есть middleware, которое создаёт/апдейтит пользователя в БД на каждый апдейт, а команда `/start` делает upsert ещё раз. Дублирование логики и два источника истины. Рекомендация: оставить регистрацию в одном месте (middleware), а `/start` только приветствие/помощь.

7) Обработка ошибок grammy
- `errorHandling` уже есть, отлично. Можно расширить логирование (userId, command, payload) и подключить трекинг (Sentry) для продакшн.

---

## Средний приоритет (Качество кода, Типы, DX)

1) Типизация контекста и user
- В `types.ts` `user?: User | null;` — хорошо. В некоторых местах делаете `ctx.user = await prisma.user.findUnique(...)` в рантайме. Убедитесь, что все участки кода, полагающиеся на `ctx.user`, идут после middleware. Где возможна гонка — делайте check+early-return (вы уже делаете).
- В helpers/profileHelper `getProfileText(user: any)` — заменить `any` на `User` из `types.ts`.

2) Импорты `.js` в TS
- Везде импорт на `.js` (например, `import { sendProfile } from "../helpers/profileHelper.js";`). Это хорошо для ESM и bundler resolution. Следите за консистентностью (в одном файле `../types` без `.js` в одном месте — `callback/profile.ts`). Там: `import type { BotContext } from "../types";` — лучше `../types.js` для единообразия ESM (или настроить resolver). Сейчас сборка, судя по build/, проходит, но единообразие уменьшит сюрпризы.

3) Повторяющиеся строки/хардкоды
- Сообщения на русском рассыпаны по коду. Для локализации/тестируемости лучше вынести строки/шаблоны в отдельный модуль или использовать простейший i18n-контейнер.
- Регулярки/строки вроде `@test_bot` — вынести в конфиг.

4) Логирование
- Много `console.log`. Для prod лучше использовать структурированное логирование (pino/tslog/winston) с уровнями, метаданными (userId, chatId, updateId) и ротацией.

5) Структура директорий
- Текущая структура ясная. Можно добавить слой `services/` для инкапсуляции бизнес-логики (Wordle, Steam), чтобы команды/колбэки были тоньше.
- Разнести слои: adapters (telegram), domain/services, infra (prisma, http), schedulers. Это облегчит тестирование.

6) Тестирование
- Сейчас нет автотестов. Минимум: модульные тесты для Wordle-логики (`getGlobalProgressWordle`, `processWordLogic` частично можно декомпозировать) и Steam-хелперов (с моками HTTP).
- E2E для команд можно собирать с useFakeBot в grammy (или e2e с Telegram Bot API тестовым токеном на sandbox).

7) Линт/форматирование
- Biome подключён — отлично. Проверьте, что пути `files/includes` охватывают весь src и конфиги. Сейчас форматер включает json; всё ок. Можно включить rule на запрет `any` и более строгие правила (но помните про DX).

---

## Низкий приоритет (Удобство, Полифилы, мелочи)

1) Стабильность fetch
- В Node/Bun fetch есть, но разная семантика таймаутов. Вы уже используете axios в ряде мест — рассмотреть унификацию: либо везде axios, либо везде fetch + обёртка для таймаута/ретрая.

2) Меню/клавиатуры
- Меню строятся инлайн — ок. Можно добавить factory-функции, чтобы избегать повторного `.row()` и сделать декларативнее (мелочь).

3) Регулярные выражения
- Регулярки в hears могут быть вынесены в константы и покрыты простыми тестами, чтобы защититься от регрессий (например, совпадения на кириллицу).

4) Улучшение UX в играх
- RPS: сейчас команды `/rock|/paper|/scissors`. Можно добавить кнопки, inline-клавиатуру и подтверждение хода.
- Wordle: добавить защиту от спама (cooldown на пользователя), а также отображение сетки прогресса/эмодзи.

---

## Прицельные замечания по файлам

- `src/bot.ts`:
  - Порядок middleware: hydrate/autoQuote/ratelimiter/session/OAuth/Middleware(constructor) — всё последовательно. Проверьте, что conversations идут после session (так и есть), хорошо.
  - Создание нового PrismaClient здесь и в `src/prisma.ts` — дублирование. Вы используете локальный в `bot.ts` только для `PrismaAdapter(prisma.session)`. Лучше переиспользовать общий экземпляр из `src/prisma.ts`, чтобы не плодить коннекты.

- `src/middleware.ts`:
  - `next: any` — заменить на `NextFunction` из grammy для типизации.
  - Частая запись в БД (update username на каждый апдейт). Можно оптимизировать: апдейтить только если username изменился.
  - Ответ пользователю "зарегистрирован" при первом апдейте может быть шумным (реагирует на любой апдейт). Возможно, лучше приветствие только по `/start`.

- `src/commands/start.ts`:
  - Дублирует регистрацию с middleware — см. выше. Лучше оставить один путь.

- `src/commands/word.ts` и `helpers/getGlobalProgressWordle.ts`:
  - Бизнес-логика приличного размера. Стоит вынести в `services/wordle.ts` с чистыми функциями, чтобы тестировать без Telegram контекста.
  - `wordleAttemptCreate()` не await'ится в одном месте — это fire-and-forget. Рекомендуется `await` или явное обоснование.

- `src/conversations/register.ts`:
  - Логи в консоль (`console.log(ctx)`, `console.log(photo.photo)`) оставить только в dev или за флагом DEBUG.
  - Обработка `/skip` нормальная, можно добавить подсказки.

- `src/conversations/savePhoto.ts`:
  - Сохранение в `src/` — см. замечание про директорию `data/`.
  - Нет проверки размера/типа файла (минимальный sanity check).

- `src/callback/steam.ts` и `helpers/steamScheduleHelper.ts`:
  - Много сетевых вызовов подряд с небольшими задержками и без retry/timeout. Вынести в сервис с политиками повторов и лимитами.
  - Местами дублирование извлечения player summary — сделать общий helper.

- `src/schedule/*`:
  - Cron `* * * * *` для Steam — каждую минуту. Следите за rate limit и нагрузкой. Возможно, 2–5 минут достаточно, а для игроков в игре — отдельная подписка/вебхук недоступен, так что compromise.
  - Логи в консоль — заменить на logger.

- `src/commands/score.ts`:
  - `const _msgId = ctx?.update?.message?.message_id;` — переменная не используется.
  - Обращение к БД дважды в ветках — можно унифицировать.

- `src/helpers/profileHelper.ts`:
  - Много степеней fallback для редактирования сообщения — здорово, но можно выделить утилиту `safeEditMediaOrCaption`.
  - Тип `user: any` — заменить на `User` из `types.ts`.

- `src/filters/url.ts`:
  - Сейчас только уведомляет о ссылке. Если планируется модерация, продумать white/black списки, автоудаление, логирование, роль модератора.

---

## Выбор библиотек — альтернативы и апгрейды

- grammy — отличный выбор. Альтернативы: telegraf (исторический), но grammy обычно быстрее и типобезопаснее.
- `@grammyjs/storage-prisma` — хорошо. Альтернатива: `@grammyjs/storage-redis` для распределённых инстансов. Если будет горизонтальное масштабирование, Prisma как session storage может стать узким местом.
- Логирование: pino/tslog/winston + pino-pretty в dev.
- Конфиг: `zod` + `dotenv` + маленький модуль валидации env при старте.
- Retrying/Timeout: `p-retry` и `p-timeout` или axios-retry.
- Task scheduling: node-cron ок. Для продакшена/масштабирования: bullmq/agenda/temporal, если задачи станут тяжелыми.

---

## DX и инфраструктура

- Добавить `docker-compose` для локальной Postgres и сервисов. В README описать переменные окружения и команды.
- Расширить README: как собрать, как запустить миграции, как запускать в dev (`bunx tsx src/bot.ts` или `bun run dev` с ts-node/tsx и nodemon/bun --watch), как стартовать прод.
- Настроить GitHub Actions: lint, typecheck, prisma format, тесты, build. Для деплоя — отдельный job.
- .env.example с перечнем ключей: BOT_TOKEN, DATABASE_URL, STEAM_API_KEY, GROUP_ID и т.д.

---

## Возможная целевая структура (опционально)

```
src/
  app/
    bot.ts           // сборка и wiring
    middleware.ts
    routes.ts        // регистрация команд/колбэков/меню
  config/
    env.ts           // zod-валидация env
    constants.ts
  domain/
    wordle/
      service.ts
      types.ts
    steam/
      service.ts
      types.ts
  infra/
    prisma.ts
    http.ts          // axios instance, retry policies
    logger.ts
    scheduler.ts
  features/
    profile/
      commands.ts
      callbacks.ts
      menu.ts
    crypto/
      commands.ts
      callbacks.ts
    ...
```

Это позволит тонким адаптерам (команды/колбэки) вызывать чистые сервисы.

---

## Резюме и быстрые победы (1–2 дня)

- Исправить `package.json` (start/readme), добавить `dev`-скрипт и корректный запуск build: `"start": "bun ./build/bot.js"`, `"dev": "bunx tsx src/bot.ts"`.
- Убрать дублирующий PrismaClient — использовать общий `src/prisma.ts` повсеместно, в т.ч. для `PrismaAdapter`.
- Вынести `groupID` и API ключи/URLы в конфиг + валидация env.
- Перенести сохранение фото из `src/` в `data/`.
- Привести импорты типов к `../types.js` (консистентно), убрать `any` в helpers.
- Добавить таймауты и базовый retry для внешних запросов.

Среднесрочно (неделя+): сервисный слой для Wordle/Steam, логгер, тесты, i18n, CI.

---

Если нужен, могу подготовить PR с безопасными изменениями по пунктам "быстрые победы" и базовым CI.
